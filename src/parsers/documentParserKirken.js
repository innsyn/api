/* Copyright 2019 Schibsted */

/***
 *
 * Can parse:
 * Kirken journals, made in DocuLive, high degree of "unstructured" parsing needed
 */
module.exports = {
  /***
   * The parse method for "Kriken" will extract data from the raw text generated by DocumentCloud
   * for a PDF.
   * To determine if the parser was able to parse the file, check the returnValue.parsed field
   * (true|false).
   */
  parse: function(raw) {
    var helper = require('./../helpers/documentParserHelper');
    var topDown = require('./topDownParser');

    var items = [];
    var globalParsed = false;
    var stashedJournal = false;
    var stash = [];

    //num fields to be complete - adjust for date special handling and others
    //TODO: swap to min number needed in checks
    var limitExpectedFields = this.options.fields.length + 1;

    //first cut; grab page by page as base line, simple split - remove rest via noise function
    //loop each page after front matter, splitting into case parts with some matching on whole text
    var pages = raw.split('OFFENTLIG POSTJOURNAL FOR');
    var limitLoop = pages.length;

    // limitLoop = (pages.length > 2) ? 4 : 0; // temp for rapid iterations

    for (var pg = 1; pg < limitLoop; pg++) {
      //make best baseline for parsing we can
      var curPg = topDown.removeNoise(pages[pg], this.options);

      var result = {};
      var item = {};

      /*
       * easy parser - grab strucutred fields caseNumber, responsible, dates, doc type
       *
       */

      //partial top down approach - how many for each, allow 1 lack if stashed
      // can also prepopulate result[] arrays from statshed, then adjust push over assign
      this.options.fields.forEach(function(field) {
        // null vs undefined quirk? -> allowEmpty false still gives undefined back
        result[field.name] = helper.getValuesFromString(
          curPg,
          field.regexList,
          true,
          field.allowNewLines,
        );
      });

      /*
       * Due to format dates are grabbed as one list, so we need to split and assign them one by one
       * TODO: refactor into testable function or functions;
       * 1 handle dates for StashedItem
       * 2 loop reminder into document and recorded
       * 3 clean up object
       */
      // split out dates into doc and journal/recorded
      var pageDates = result.pageDates;
      result['recordedDate'] = [];
      result['documentDate'] = [];

      // first filling up statshed object dates if missing
      if (stashedJournal) {
        item = stash.pop();
        if (typeof item['recordedDate'] === 'undefined') {
          item['recordedDate'] = pageDates.shift();
          item.fieldCount++;
        }
        if (typeof item['documentDate'] === 'undefined') {
          item['documentDate'] = pageDates.shift();
          item.fieldCount++;
        }
      }
      // - then split reminder into two equal arrays (if even # hits)
      //todo: improve to verify older/newer pattern?
      var dateLoopLength = pageDates.length;
      for (var dateIndex = 0; dateIndex < dateLoopLength; dateIndex++) {
        if (dateIndex % 2) {
          result['documentDate'].push(pageDates.shift());
        } else {
          result['recordedDate'].push(pageDates.shift());
        }
      }
      // - and finally remove and trace before doing for-in
      delete result.pageDates;

      // console.log( "rec" + result["recordedDate"].length );
      // console.log( "doc" + result["documentDate"].length );

      /*
       * end of date edge handling
       */

      /*
       * Title special code including stash
       *
       */
      var fieldTitle = {
        name: 'caseTitle',
        regexList: [
          /Sakstittel[\s]+(.+[\n]?.*)/,
          /Sakstittel[\s]+([\s\S]+?)Brev.dato/,
          /Sakstittel([\s\S]+?)Dokumenttittel/,
          /Sakstittel([\s\S]+?)Sakstittel/,
          /Sakstittel[\s]+([\S]+)$/,
          /(Sakstittel)/,
        ],
      };

      // ...
      var cases = curPg.split('Arkivsak/doknr');
      // console.log(cases.length);

      var titles = [];

      //get any from first part and add to array in front
      // handle blank/undefined && stashed.caseTitle == "Sakstittel"
      if (stashedJournal) {
        //this should run in all cases, but save to stashed only if missing -
        // since pg13 shows that caseId + caseTitle can be "jumped" up one step
        // we could see cae 0 also having a full Sakstittel for case 1
        var rawResult = helper.getValueFromString(
          cases[0],
          fieldTitle.regexList,
        );
        if (rawResult == '') {
          var bruteHit = [
            /([ÆØÅA-Z]{1}.*)[\n]+Brev.dato/,
            /([ÆØÅA-Z]{1}.+[\n]?.*)[\n]+Dokumenttittel/,
          ];
          rawResult = helper.getValueFromString(cases[0], bruteHit);
        }

        if (rawResult) {
          var resultTitle = helper.removeNewLines(rawResult);
          // console.log("up front:" + resultTitle);
          titles[0] = resultTitle;
        }
      }

      if (stashedJournal) {
        //grab any extra element from stashed (ie missing "Sakstittel" since on prev page)
        var bruteHit = [
          /([ÆØÅA-Z]{1}.+[\n]?.*)[\n]+Brev.dato/,
          /([ÆØÅA-Z]{1}.+[\n]?.*)[\n]+Dokumenttittel/,
        ];
        //split out pre Sakstittel in last block
        var rawText = cases[cases.length - 1].split('Sakstittel')[0];
        var rawResult = helper.getValueFromString(rawText, bruteHit);

        if (rawResult) {
          var resultTitleEnd = helper.removeNewLines(rawResult);
          // console.log( "extra regExp: " + resultTitleEnd);
          titles[0] = resultTitleEnd;
        }
      }

      //grab any that should be directly in the flow
      //TODO: verify add to final unified array in full flow
      for (var caseNum = 1; caseNum < cases.length - 1; caseNum++) {
        var rawResult = helper.getValueFromString(
          cases[caseNum],
          fieldTitle.regexList,
        );
        if (rawResult) {
          var resultDirect = helper.removeNewLines(rawResult);
          // console.log(caseNum + ": " + resultDirect);

          // can we grab extra number and verify placement?
          var caseText = cases[caseNum];
          var regCase = /(\d{2,4}\/\d{1,6}-\d{1,6})/g;
          var caseHits = caseText.match(regCase);

          if (caseHits && caseHits.length >= 2) {
            //there are TWO case ids in the fragement, need to assign title to correct one
            var firstId = caseText.search(regCase);
            var secondId = caseText.substr(firstId + 1).search(regCase);

            var resultId = caseText.indexOf('Sakstittel');
            var resultCase = resultId > secondId ? caseHits[1] : caseHits[2];

            // console.log("1: " + firstId + " 2: " + secondId);
            // console.log("hit: " + resultId + " for " + resultCase);

            //save to right one - needs to be done when have a set of results with caseNumber already in place
            for (
              var caseNum = 0;
              caseNum < result.caseNumber.length - 1;
              caseNum++
            ) {
              if (result.caseNumber[caseNum] == resultId) {
                if (stashedJournal) {
                  titles[caseNum] = resultCase;
                } else {
                  titles[caseNum - 1] = resultCase;
                }
              }
            }
          } else {
            //TODO: improve to use and verfiy case number here as well
            if (stashedJournal) {
              titles[caseNum] = resultDirect;
            } else {
              titles[caseNum - 1] = resultDirect;
            }
          }
        } // else none found
      }

      // console.log("pre:" + titles );

      //grab the majority of items from the last part of page
      finalResults = helper.getValuesFromString(
        cases[cases.length - 1],
        fieldTitle.regexList,
        true,
        false,
      );
      // console.log( finalResults );

      //while / do style - as long as we have items, keep incrementing in titles to fill
      var tLoop = 0;
      while (finalResults.length) {
        if (titles[tLoop]) {
        } else {
          titles[tLoop] = finalResults.shift();
        }
        tLoop++;
      }

      // console.log("post:");
      // console.log( titles );
      result.caseTitle = titles;

      /*
       * end of title edge handling
       */

      //Fill up reminder of stashed missing fields from simple parsing
      if (stashedJournal) {
        for (var field in result) {
          //console.log(result[field][0]);
          if (typeof item[field] === 'undefined') {
            item[field] = result[field].shift();
            item.fieldCount++;
            //console.log(item.fieldCount + " in stash loop" + item[field]);
          }
        }
        // new new logic since dates buggy - should we push it with some blanks?
        // adjust for title +1 more
        if (item.fieldCount > limitExpectedFields) {
          items.push(item);
          // console.log("from stash: " );
          // console.log(item);
          stashedJournal = false;
        }
        // else log?
      }

      // then allow full match number items from page
      // TODO: validate max/min num hits
      // - now using caseNumber as proxy - first line so should be stashed if incomplete
      for (var i = 0; i < result.caseNumber.length; i++) {
        var item = {};
        item.fieldCount = 0;
        //swap order of loops?
        for (var field in result) {
          if (result[field][i]) {
            // ignore undefined?
            item[field] = result[field][i];
            item.fieldCount++;
          } else {
            // console.log(field + "fail " + i);
          }
        }

        // are we getting "enough" fields for journal? if not stash reminder data
        // update for title
        //TODO: check last page - return not stash...?
        if (item.fieldCount > limitExpectedFields) {
          items.push(item);
          globalParsed = true;
        } else {
          stashedJournal = true;
          stash.push(item);
          // console.log("stashing");
          // console.log(item);
        }
      }
    }

    console.log('total pages:' + pages.length);
    console.log('parsed: ' + items.length);

    // clean up data on each item, change date format for database, signal type
    // documentType Avsender -> I, Mottaker -> U
    for (var itemCleaned = 0; itemCleaned < items.length; itemCleaned++) {
      var cleanIt = items[itemCleaned];
      cleanIt.documentDate = getDateFromString(cleanIt.documentDate);
      cleanIt.recordedDate = getDateFromString(cleanIt.recordedDate);
      cleanIt.documentType = cleanIt.documentType == 'Avsender' ? 'I' : 'U';
    }

    //return the array of parsed items and status or default error message
    if (globalParsed) {
      return { parsed: true, items: items };
    }
    return {
      parsed: false,
      items: items,
      error: { message: 'No items found in source' },
    };

    /***
     * Uses the documentParserHelper method directly
     * todo: consider exposing this also as a helper function, since duplicated with UniBlue
     */
    function parseSingle(raw, options) {
      var result = {};
      options.fields.forEach(function(field) {
        var rawResult = helper.getValueFromString(raw, field.regexList);
        result[field.name] = field.allowNewLines
          ? rawResult
          : helper.removeNewLines(rawResult);
      });

      return result;
    }

    /***
     * Converts a string with the format "dd.mm.yyyy" to a date object.
     * todo: move generic function inside parserHelper? call with format style
     */
    function getDateFromString(dateString) {
      try {
        if (dateString.length === 10) {
          var dateParts = dateString.split('.');
          var year = dateParts[2];
          var month = dateParts[1];
          var day = dateParts[0];
        } else {
          return '';
        }
        /*
         Parse the date as a string to avoid one day offset
         http://stackoverflow.com/questions/7556591/javascript-date-object-always-one-day-off)
         */
        return new Date('"' + year + '/' + month + '/' + day + '"');
      } catch (e) {
        return '';
      }
    }
  },

  options: {
    fields: [
      //util - shift out to clean up result array
      {
        name: 'pageDates',
        regexList: [/(\d{2}\.\d{2}\.\d{4})/],
      },
      {
        name: 'caseNumber',
        regexList: [/(\d{2,4}\/\d{1,6}-\d{1,6})/],
      },

      // {
      //   name: "caseTitle",
      //   regexList: [
      //     /Sakstittel[\s]+(.+[\n]?.*)/,
      //     /Sakstittel[\s]+([\s\S]+?)Brev.dato/,
      //     /Sakstittel([\s\S]+?)Dokumenttittel/,
      //     /Sakstittel([\s\S]+?)Sakstittel/,
      //     /Sakstittel([\s\S]+?)$/,
      //     /(Sakstittel)/,
      //   ]
      // },

      // {
      //   name: "documentTitle",
      //   regexList: [
      //     /(.+)\nSaksansv:/,
      //     /(.+) Saksansv:/,
      //     /Sakstittel er avskjermet\n(.+)/,

      //     /(Andre opplysninger er avskjermet)/
      //   ]
      // },

      {
        //KR-KR-INFAVD-TEV and KR- -THW and KR-MENAVD-***-*** partial classified
        name: 'caseResponsible',
        regexList: [
          /(KR-[A-ZÆØÅ]+-[A-ZÆØÅ]+-[A-ZÆØÅ]+)/,
          /(KR- -[A-ZÆØÅ]+)/,
          /(KR-[A-ZÆØÅ]+-[\*]{3}-[\*]{3})/,
        ],
      },
      {
        name: 'documentType',
        regexList: [/(Avsender|Mottaker)/],
      },
      // {
      //   name: "sender",
      //   regexList: [
      //     /Fra:\n(.+)\nSak:/,
      //     /Sek.kode:\n(.+)\nI/,
      //     /Jour.dato: \d{4}-\d{2}-\d{2}\n(.+)\nI/,
      //     /Fra:\n(.+)[\s\S]*?Dok:/,
      //     /Fra:\n(.+)[\s\S]*?Grad:/
      //   ]
      // },
      // {
      //   name: "receiver",
      //   regexList: [
      //     /Til:\n(.+)\n/,
      //     /Til:\n([\s\S]*?)\nSak:/
      //   ]
      // },

      // store archive code here - 1-KRSF-046 ...?
      // {
      //   name: "classification",
      //   regexList: [
      //     /Grad:(.+)/,
      //   ]
      // }
    ],

    // remove header text on each page to simplify flow
    noise: [
      /KONTOR I DEN NORSKE KIRKE/g,
      /Side \d+/g,
      /Notat, inn- og utgående post, De sentralkirkelige råd - Kirkerådet,/g,
      /for perioden: \d{2}\.\d{2}\.\d{4} \d{2}\.\d{2}\.\d{4}/g,
    ],
  },
};
