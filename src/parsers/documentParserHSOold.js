/* Copyright 2019 Schibsted */

/***
 *
 * Can parse:
 * HSO old journals
 *
 */
module.exports = {
  /***
   * The parse method for "HSO" will extract data from the raw text generated by DocumentCloud
   * for a PDF.
   * To determine if the parser was able to parse the file, check the returnValue.parsed field
   * (true|false).
   */
  parse: function(raw) {
    var helper = require('./../helpers/documentParserHelper');

    var items = [];
    var globalParsed = false;

    var cases = raw.split(/(\d{1,4}\/\d{3,8}-\d{1,4})/);

    //loop on two by two, grab id into resulting item post parse
    for (var i = 1; i < cases.length; i += 2) {
      var itemId = cases[i];
      var result = parseSingle(cases[i + 1], this.options);

      if (result) {
        //clean up data for DB, resolve ambiguity...
        globalParsed = true;

        var item = result;
        item.caseNumber = itemId;

        // add expected fields (sender, receiver) based on meta hits on labeling
        item.receiver = item.sender = '';

        if (item.senderOrReceiverLabel == 'Mottaker:') {
          item.receiver = item.senderOrReceiver;
          item.documentType = 'U';
        } else {
          item.sender = item.senderOrReceiver;
          item.documentType = 'I';
        }

        //adjust date format to date format
        item.documentDate = getDateFromString(item.documentDate);
        item.recordedDate = getDateFromString(item.recordedDate);

        items.push(item);
      } else {
        // console.log("failed" + i);
        // if(i == 87 ) console.log(cases[i+1]);
      }
    }

    console.log(
      'total:' + cases.length + ' expected cases: ' + (cases.length - 1) / 2,
    );
    console.log('parsed: ' + items.length);

    //return the array of parsed items and status or default error message
    if (globalParsed) {
      return { parsed: true, items: items };
    }
    return {
      parsed: false,
      items: items,
      error: { message: 'No items found in source' },
    };

    /***
     * Uses the documentParserHelper method directly
     * todo: consider exposing this also as a helper function, since duplicated with UniBlue
     */
    function parseSingle(raw, options) {
      var result = {};
      options.fields.forEach(function(field) {
        var rawResult = helper.getValueFromString(raw, field.regexList);
        result[field.name] = field.allowNewLines
          ? rawResult
          : helper.removeNewLines(rawResult);
      });

      return result;
    }

    /***
     * Converts a string with the format "dd.mm.yyyy" to a date object.
     */
    // from Kemner - move to helper used inside topDown?
    function getDateFromString(dateString) {
      try {
        if (dateString.length === 8) {
          var year = dateString.substring(4, 8);
          var month = dateString.substring(2, 4);
          var day = dateString.substring(0, 2);
        } else {
          return '';
        }
        /*
         Parse the date as a string to avoid one day offset
         http://stackoverflow.com/questions/7556591/javascript-date-object-always-one-day-off)
         */
        return new Date('"' + year + '/' + month + '/' + day + '"');
      } catch (e) {
        return '';
      }
    }
  },

  options: {
    fields: [
      // { // use for split
      //   name: "caseNumber",
      //   regexList: [
      //     /(\d{1,4}\/\d{2,7}-\d{1,4})/
      //   ]
      // },
      // roughly wrong, need multi handling if priority
      {
        name: 'documentTitle',
        regexList: [/.+[\n].+[\n](.+)[\n]Saksansv/, /(Avskjermet)/],
      },
      {
        name: 'caseTitle',
        regexList: [
          /.+[\n](.+)[\n].+[\n]Saksansv/,
          /(Avskjermet)/,
          /Dok:([\s\S]*?)Saksansv/,
        ],
      },
      {
        name: 'senderOrReceiver',
        regexList: [/(.+)[\n].+[\n].+[\n]Saksansv/, /(Avskjermet)/],
      },
      {
        name: 'senderOrReceiverLabel',
        regexList: [/(Mottaker:|Avsender:)/, /(Avskjermet)/],
      },
      //Dok.dato: 08012014 Jour.dato: 16012014
      {
        name: 'documentDate',
        regexList: [/Dok.dato: (.*) Jour.dato:/, /Dok.dato: (.*)/],
      },
      {
        name: 'recordedDate',
        regexList: [/Jour.dato: (.*)/],
      },
      {
        name: 'caseOfficer',
        regexList: [/Saksbeh:(.*)/, /(Andre opplysninger er avskjermet)/],
      },
      {
        name: 'caseResponsible',
        regexList: [
          /Saksansv:(.*)/,
          /Saksansv:([\s\S]*?)Saksbeh:/,
          /(Andre opplysninger er avskjermet)/,
        ],
      },

      // // SSHF tweaks - consider option to extend config? or add as extra regexp
      // {
      //   name: "classification",
      //   regexList: [
      //     /Klasse:([\s\S]*?)Dok.:/,
      //     /Klasse:\n\n(.*)/
      //   ]
      // },
      {
        name: 'legalParagraph',
        regexList: [/Par.:(.*)/],
      },
    ],

    noise: [],
  },
};
