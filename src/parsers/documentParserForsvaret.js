/* Copyright 2019 Schibsted */

/***
 *
 * Can parse:
 * Forsvaret journals, made in DocuLive, high degree of "screened" data
 *
 */
module.exports = {
  /***
   * The parse method for "Forsvaret" will extract data from the raw text generated by DocumentCloud
   * for a PDF.
   * To determine if the parser was able to parse the file, check the returnValue.parsed field
   * (true|false).
   */
  parse: function(raw) {
    const helper = require('./../helpers/documentParserHelper');

    const items = [];
    let globalParsed = false;

    // Remove clutter from the document. Abstract?
    const sanitizeDocument = function(document) {
      const lines = document
        .split('\n')
        .filter(line => !/^DocuLive rapport|\fDocuLive rapport/.test(line))
        .filter(line => !/^[ ]*Offentlig journal/.test(line))
        .filter(line => !/^[ ]*Side/.test(line))
        .filter(line => !/^[ ]*Periode:/.test(line))
        .filter(line => !/^[ ]*Journalenhet:/.test(line))
        .filter(line => !/^[ ]*Org.enhet:/.test(line))
        .filter(line => !/^[ ]*Underliggende enhet/.test(line))
        .filter(line => !/^[ ]*Saksbehandler/.test(line))
        .filter(line => !/^[ ]*Notater/.test(line))
        .filter(line => line.length > 0);

      return lines.join('\n');
    };

    const cases = sanitizeDocument(raw).split(/(20\d{3,9}-\d{1,4})/);

    //loop on two by two, grab id into resulting item post parse
    for (let i = 1; i < cases.length; i += 2) {
      const itemId = cases[i];
      const result = parseSingle(cases[i + 1], this.options);

      if (result) {
        //clean up data for DB, resolve ambiguity...
        globalParsed = true;

        const item = result;
        item.caseNumber = itemId;

        //adjust date format to date format
        item.documentDate = getDateFromString(item.documentDate);
        item.recordedDate = getDateFromString(item.recordedDate);

        // TODO: Configurable?
        item.caseTitle = item.caseTitle.replace(/\s\s+/g, ' ');
        item.documentTitle = item.documentTitle.replace(/\s\s+/g, ' ');

        //normalize for unknown doc types
        item.documentType = item.documentType || 'Avskj';

        const [, sender, ...receivers] = item.senderOrReciever
          .split('  ')
          .filter(line => line.length > 0)
          .map(value => value.trim());

        if (item.sender === '') {
          // console.log(item);
          item.sender = sender;
        }

        if (item.receiver === '') {
          item.receiver = receivers.join(' ');
        }

        delete item.senderOrReciever;

        items.push(item);
      } else {
        // console.log("failed" + i);
        // if(i == 87 ) console.log(cases[i+1]);
      }
    }

    // console.log("total:" + cases.length + " expected cases: " + ((cases.length-1)/2) );
    // console.log("parsed: " + items.length);

    //return the array of parsed items and status or default error message
    if (globalParsed) {
      return { parsed: true, items: items };
    }
    return {
      parsed: false,
      items: items,
      error: { message: 'No items found in source' },
    };

    /***
     * Uses the documentParserHelper method directly
     * todo: consider exposing this also as a helper function, since duplicated with UniBlue
     */
    function parseSingle(raw, options) {
      var result = {};
      options.fields.forEach(function(field) {
        var rawResult = helper.getValueFromString(raw, field.regexList);
        result[field.name] = field.allowNewLines
          ? rawResult
          : helper.removeNewLines(rawResult);
      });

      return result;
    }

    /***
     * Converts a string with the format "dd.mm.yyyy" to a date object.
     * todo: move generic function inside parserHelper? call with format style
     */
    function getDateFromString(dateString) {
      try {
        if (dateString.length === 10) {
          var dateParts = dateString.split('-');
          var year = dateParts[0];
          var month = dateParts[1];
          var day = dateParts[2];
        } else {
          return '';
        }
        /*
         Parse the date as a string to avoid one day offset
         http://stackoverflow.com/questions/7556591/javascript-date-object-always-one-day-off)
         */
        return new Date('"' + year + '/' + month + '/' + day + '"');
      } catch (e) {
        return '';
      }
    }
  },

  options: {
    fields: [
      {
        name: 'caseTitle',
        regexList: [
          /(Sakstittel er avskjermet)/,
          /(Andre opplysninger er avskjermet)/,
          /Sak:[ ]*([^]*?)(?=Dok:)/,
        ],
      },
      {
        name: 'documentTitle',
        regexList: [
          /(Andre opplysninger er avskjermet)/,
          /Dok:[ ]*([^]*?)(?=Saksansv:|Saksbeh:)/,
        ],
      },
      {
        name: 'sender',
        regexList: [/Fra:[ ]*(.*?)(?=Til:|\n)/],
      },
      {
        name: 'receiver',
        regexList: [/Til:[ ]*(.+)/],
      },
      {
        name: 'documentDate',
        regexList: [
          /Dok.dato: (\d{4}-\d{2}-\d{2})\nJour.dato/,
          /Dok.dato:([\s\S]*?)Arkivkode:/,
        ],
      },
      {
        name: 'recordedDate',
        regexList: [
          /Jour.dato: (\d{4}-\d{2}-\d{2})/,
          /Jour.dato:([\s\S]*?)Sek.kode:/,
        ],
      },
      {
        name: 'caseResponsible',
        regexList: [/Saksansv:(.+)/],
      },
      {
        name: 'caseOfficer',
        regexList: [
          /Saksbeh:[\s]*?(.+)[\s]*?20\d{3,9}/,
          /Saksbeh:[\s]*?(.+)[\s]*?Side/,
          /Saksbeh:(.+)/,
          /Saksbeh:[\s]*?(.+)/,
        ],
      },
      {
        name: 'documentType',
        regexList: [/(T|U|N|I|X){1}[ ]*(?=Fra:)/],
      },
      {
        name: 'classification',
        regexList: [/Grad:[ ]*(.*?)(?=Par\.:)/],
      },
      {
        name: 'legalParagraph',
        regexList: [/Par\.:(.+)/],
      },
      {
        name: 'senderOrReciever',
        regexList: [/Fra:([^]+)Sakstittel er avskjermet/, /Fra:([^]+)Sak:/],
      },
    ],

    noise: [/Offentlig journal/g],
  },
};
